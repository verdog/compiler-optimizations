# cs6810-iloc-ssa-optimizer-project
# Josh Chandler

## Building

Run the following in the root directory of the repository (the same directory that this README is in):
```bash
make
```

**Sometimes the build process will randomly fail**... probably because of the fact that `make` is configured to build with multiple threads. Just run make again and it should work out.

There are 3 components to this project, and calling `make` will build each one in the following order:
1. The antlr4 runtime library

This is needed for antlr4 to work and has definitions for core antlr4 functionality.

You can find the source code for this portion in [./antlr/lib/antlr4-runtime](./antlr/lib/antlr4-runtime/src). I copied the code from [the official antlr4 repository](https://github.com/antlr/antlr4/tree/master/runtime/Cpp/runtime/src).

2. The parser functions generated by antlr4

This generates the classes such as `ilocBaseVisitor` which I extend.

You can find the grammar file and the generated library in [./antlr/src/parser](./antlr/src/parser). It uses the antlr4 jar file to generate c++ files. The jar file is in [./antlr/lib/](./antlr/lib).

3. My driver and optimizer code

This uses the generated antlr4 code to parse an iloc file, extract basic blocks, and apply LVN.

The source code for this portion is in [.antlr/src/driver](./antlr/src/driver).

## Scripts

### `iopt.sh`

Once you've built the project, you can use `iopt.sh`, found at the root level of this repository (the same level as this README), to run every `.il` file in `./input` through the optimizer. The optimized files are saved in `./output` as `{filename}.opt.il`. The script first outputs the time it took to optimize each file, and then it outputs the difference between the outputs of the original `.il` file and the optimized `opt.il` file.

### `./antlr/quick-test.sh`

This script provides part of the functionality for the master `iopt.sh` script.

It tests the output differences between an unoptimized and optimized `.il` file. 

You must be in the `./antlr` directory to use this script. Usage:
```bash
cd ./antlr # must be here!
quick-test.sh ../input/qs.il # tests qs.il
quick-test.sh # tests all files in ../input
```

## Report

### Optimizations Performed

In the current state of the optimizer, the following optimizations are applied. 

First, local value numbering is done. Then, the program is converted to SSA form. While the program is being converted to SSA form, global common subexpression elimination is done. Lastly, SSA based dead code elimination is done.

### Problems Faced

I faced two big problems during the implementation of global common subexpression elimination.

#### Malformed Input Iloc

To implement global common subexpression elimination, we need to utilize the fact that in iloc, syntactically equivalent expressions always store into the same register. However, not all input provided actually followed this. For example, while_array.il:

```
...
	testle	%vr7  => %vr8         <--
	cbr	%vr8  -> .L1
.L0:	nop
	loadI	1  => %vr5
	i2i	%vr5  => %vr4
	loadI	10  => %vr6
	comp	%vr4, %vr6 => %vr7
	testgt	%vr7  => %vr8         <--
...
```

These two `test` instructions are actually different operations, but they store into the same register. To address this issue, instead of storing "what defined `%vr8`" when I see it, I store something more like "what *last* defined `%vr8`, and does it exactly match what I'm currently looking at?".

#### Memory Registers VS Expression Registers

Another instance of instructions "breaking" the "syntactic equivalence" rule of iloc are `i2i` instructions. I don't actually believe they're "breaking" the rule, because I remember talking about the distinction between memory and expression registers in class, but it still needed to be accounted for.

This was further complicated by the fact that local value numbering was changing some `i2i` instructions into `loadI` instructions, so they would *appear* to be expression registers, but later be used later as memory registers.

To address this issue, before any optimization pass got to touch the input code, I had another pass go through each instruction and mark it as a memory register or an expression register based on the opcode in used in the instruction that defined it. Then, in my optimizer code, I would never delete instructions that store to a memory register.

After that, I realized that some expressions *used* memory registers as operands and it would sometimes mean I couldn't delete them, even if I had already seen them. The reason I couldn't delete them was the following: because memory registers don't follow the "syntactic equivalence" rule of iloc, a syntactically equivalent expression that used a memory register could still be semantically different.

To address this, when marking registers as memory or expression registers, I introduced a third register type called a "mixed expression" register. A mixed expression register is an expression register that uses memory registers as operands and is not allowed to be deleted.

### Statistics

| File | Original Number of Instructions | Optimizer Runtime | Optimized Number of Instructions | Percent Removed ($1 - \frac{Optimized}{Original}$) |
|-|-|-|-|-|
| `arrayparam.il` | 841 | 0.278s | 474 | 43.6% |
| `bubble.il` | 4374 | 1.013s | 2761 | 36.7% |
| `check.il` | 140 | 0.055s | 5 | 96.4% |
| `dynamic.il` | 39155 | 5.765s | 24335 | 37.8% |
| `fib.il` | 274 | 0.040s | 230 | 16.1% |
| `gcd.il` | 103 | 0.096s | 84 | 18.4% |
| `newdyn.il` | 136919 | 2.155s | 85151 | 37.8% |
| `qs.il` | 4574 | 0.568s | 3464 | 24.3% |
| `while_array.il` | 377 | 0.127s | 278 | 26.3% |
